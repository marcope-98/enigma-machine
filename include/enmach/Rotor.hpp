#ifndef ENMACH_ROTOR_HPP_
#define ENMACH_ROTOR_HPP_

#include <array>
#include <cstdint>
#include <type_traits>

#include "enmach/common.hpp"
#include "enmach/utils.hpp"

#define EKMFLGDQVZNTOWYHXUSPAIBRCJ { 0x04, 0x0a, 0x0c, 0x05, 0x0b, 0x06, 0x03, 0x10, 0x15, 0x19, 0x0d, 0x13, 0x0e, 0x16, 0x18, 0x07, 0x17, 0x14, 0x12, 0x0f, 0x00, 0x08, 0x01, 0x11, 0x02, 0x09 }
#define UWYGADFPVZBECKMTHXSLRINQOJ { 0x14, 0x16, 0x18, 0x06, 0x00, 0x03, 0x05, 0x0f, 0x15, 0x19, 0x01, 0x04, 0x02, 0x0a, 0x0c, 0x13, 0x07, 0x17, 0x12, 0x0b, 0x11, 0x08, 0x0d, 0x10, 0x0e, 0x09 }
#define AJDKSIRUXBLHWTMCQGZNPYFVOE { 0x00, 0x09, 0x03, 0x0a, 0x12, 0x08, 0x11, 0x14, 0x17, 0x01, 0x0b, 0x07, 0x16, 0x13, 0x0c, 0x02, 0x10, 0x06, 0x19, 0x0d, 0x0f, 0x18, 0x05, 0x15, 0x0e, 0x04 }
#define AJPCZWRLFBDKOTYUQGENHXMIVS { 0x00, 0x09, 0x0f, 0x02, 0x19, 0x16, 0x11, 0x0b, 0x05, 0x01, 0x03, 0x0a, 0x0e, 0x13, 0x18, 0x14, 0x10, 0x06, 0x04, 0x0d, 0x07, 0x17, 0x0c, 0x08, 0x15, 0x12 }
#define BDFHJLCPRTXVZNYEIWGAKMUSQO { 0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x02, 0x0f, 0x11, 0x13, 0x17, 0x15, 0x19, 0x0d, 0x18, 0x04, 0x08, 0x16, 0x06, 0x00, 0x0a, 0x0c, 0x14, 0x12, 0x10, 0x0e }
#define TAGBPCSDQEUFVNZHYIXJWLRKOM { 0x13, 0x00, 0x06, 0x01, 0x0f, 0x02, 0x12, 0x03, 0x10, 0x04, 0x14, 0x05, 0x15, 0x0d, 0x19, 0x07, 0x18, 0x08, 0x17, 0x09, 0x16, 0x0b, 0x11, 0x0a, 0x0e, 0x0c }
#define ESOVPZJAYQUIRHXLNFTGKDCMWB { 0x04, 0x12, 0x0e, 0x15, 0x0f, 0x19, 0x09, 0x00, 0x18, 0x10, 0x14, 0x08, 0x11, 0x07, 0x17, 0x0b, 0x0d, 0x05, 0x13, 0x06, 0x0a, 0x03, 0x02, 0x0c, 0x16, 0x01 }
#define HZWVARTNLGUPXQCEJMBSKDYOIF { 0x07, 0x19, 0x16, 0x15, 0x00, 0x11, 0x13, 0x0d, 0x0b, 0x06, 0x14, 0x0f, 0x17, 0x10, 0x02, 0x04, 0x09, 0x0c, 0x01, 0x12, 0x0a, 0x03, 0x18, 0x0e, 0x08, 0x05 }
#define VZBRGITYUPSDNHLXAWMJQOFECK { 0x15, 0x19, 0x01, 0x11, 0x06, 0x08, 0x13, 0x18, 0x14, 0x0f, 0x12, 0x03, 0x0d, 0x07, 0x0b, 0x17, 0x00, 0x16, 0x0c, 0x09, 0x10, 0x0e, 0x05, 0x04, 0x02, 0x0a }
#define QCYLXWENFTZOSMVJUDKGIARPHB { 0x10, 0x02, 0x18, 0x0b, 0x17, 0x16, 0x04, 0x0d, 0x05, 0x13, 0x19, 0x0e, 0x12, 0x0c, 0x15, 0x09, 0x14, 0x03, 0x0a, 0x06, 0x08, 0x00, 0x11, 0x0f, 0x07, 0x01 }
#define JPGVOUMFYQBENHZRDKASXLICTW { 0x09, 0x0f, 0x06, 0x15, 0x0e, 0x14, 0x0c, 0x05, 0x18, 0x10, 0x01, 0x04, 0x0d, 0x07, 0x19, 0x11, 0x03, 0x0a, 0x00, 0x12, 0x17, 0x0b, 0x08, 0x02, 0x13, 0x16 }
#define SKXQLHCNWARVGMEBJPTYFDZUIO { 0x12, 0x0a, 0x17, 0x10, 0x0b, 0x07, 0x02, 0x0d, 0x16, 0x00, 0x11, 0x15, 0x06, 0x0c, 0x04, 0x01, 0x09, 0x0f, 0x13, 0x18, 0x05, 0x03, 0x19, 0x14, 0x08, 0x0e }
#define NZJHGRCXMYSWBOUFAIVLPEKQDT { 0x0d, 0x19, 0x09, 0x07, 0x06, 0x11, 0x02, 0x17, 0x0c, 0x18, 0x12, 0x16, 0x01, 0x0e, 0x14, 0x05, 0x00, 0x08, 0x15, 0x0b, 0x0f, 0x04, 0x0a, 0x10, 0x03, 0x13 }
#define QMGYVPEDRCWTIANUXFKZOSLHJB { 0x10, 0x0c, 0x06, 0x18, 0x15, 0x0f, 0x04, 0x03, 0x11, 0x02, 0x16, 0x13, 0x08, 0x00, 0x0d, 0x14, 0x17, 0x05, 0x0a, 0x19, 0x0e, 0x12, 0x0b, 0x07, 0x09, 0x01 }
#define FKQHTLXOCBJSPDZRAMEWNIUYGV { 0x05, 0x0a, 0x10, 0x07, 0x13, 0x0b, 0x17, 0x0e, 0x02, 0x01, 0x09, 0x12, 0x0f, 0x03, 0x19, 0x11, 0x00, 0x0c, 0x04, 0x16, 0x0d, 0x08, 0x14, 0x18, 0x06, 0x15 }
#define QJINSAYDVKBFRUHMCPLEWZTGXO { 0x10, 0x09, 0x08, 0x0d, 0x12, 0x00, 0x18, 0x03, 0x15, 0x0a, 0x01, 0x05, 0x11, 0x14, 0x07, 0x0c, 0x02, 0x0f, 0x0b, 0x04, 0x16, 0x19, 0x13, 0x06, 0x17, 0x0e }
#define LEYJVCNIXWPBQMDRTAKZGFUHOS { 0x0b, 0x04, 0x18, 0x09, 0x15, 0x02, 0x0d, 0x08, 0x17, 0x16, 0x0f, 0x01, 0x10, 0x0c, 0x03, 0x11, 0x13, 0x00, 0x0a, 0x19, 0x06, 0x05, 0x14, 0x07, 0x0e, 0x12 }
#define RLFOBVUXHDSANGYKMPZQWEJICT { 0x11, 0x0b, 0x05, 0x0e, 0x01, 0x15, 0x14, 0x17, 0x07, 0x03, 0x12, 0x00, 0x0d, 0x06, 0x18, 0x0a, 0x0c, 0x0f, 0x19, 0x10, 0x16, 0x04, 0x09, 0x08, 0x02, 0x13 }
#define FSOKANUERHMBTIYCWLQPZXVGJD { 0x05, 0x12, 0x0e, 0x0a, 0x00, 0x0d, 0x14, 0x04, 0x11, 0x07, 0x0c, 0x01, 0x13, 0x08, 0x18, 0x02, 0x16, 0x0b, 0x10, 0x0f, 0x19, 0x17, 0x15, 0x06, 0x09, 0x03 }
#define ELPZHAXJNYDRKFCTSIBMGWQVOU { 0x04, 0x0b, 0x0f, 0x19, 0x07, 0x00, 0x17, 0x09, 0x0d, 0x18, 0x03, 0x11, 0x0a, 0x05, 0x02, 0x13, 0x12, 0x08, 0x01, 0x0c, 0x06, 0x16, 0x10, 0x15, 0x0e, 0x14 }

namespace enmach::rotor_tags
{
  // clang-format off
  struct I     { constexpr static std::array<std::uint8_t, 26> fvalue = EKMFLGDQVZNTOWYHXUSPAIBRCJ, 
                                                               rvalue = UWYGADFPVZBECKMTHXSLRINQOJ; 
                 constexpr static auto turn(std::uint8_t position) -> bool { return position == 16U; } };
  struct II    { constexpr static std::array<std::uint8_t, 26> fvalue = AJDKSIRUXBLHWTMCQGZNPYFVOE, 
                                                               rvalue = AJPCZWRLFBDKOTYUQGENHXMIVS; 
                 constexpr static auto turn(std::uint8_t position) -> bool { return position ==  4U; } };
  struct III   { constexpr static std::array<std::uint8_t, 26> fvalue = BDFHJLCPRTXVZNYEIWGAKMUSQO, 
                                                               rvalue = TAGBPCSDQEUFVNZHYIXJWLRKOM; 
                 constexpr static auto turn(std::uint8_t position) -> bool { return position == 21U; } };
  struct IV    { constexpr static std::array<std::uint8_t, 26> fvalue = ESOVPZJAYQUIRHXLNFTGKDCMWB, 
                                                               rvalue = HZWVARTNLGUPXQCEJMBSKDYOIF; 
                 constexpr static auto turn(std::uint8_t position) -> bool { return position ==  9U; } };
  struct V     { constexpr static std::array<std::uint8_t, 26> fvalue = VZBRGITYUPSDNHLXAWMJQOFECK, 
                                                               rvalue = QCYLXWENFTZOSMVJUDKGIARPHB; 
                 constexpr static auto turn(std::uint8_t position) -> bool { return position == 25U; } };
  struct VI    { constexpr static std::array<std::uint8_t, 26> fvalue = JPGVOUMFYQBENHZRDKASXLICTW, 
                                                               rvalue = SKXQLHCNWARVGMEBJPTYFDZUIO; 
                 constexpr static auto turn(std::uint8_t position) -> bool { return position == 25U || position == 12U; } };
  struct VII   { constexpr static std::array<std::uint8_t, 26> fvalue = NZJHGRCXMYSWBOUFAIVLPEKQDT, 
                                                               rvalue = QMGYVPEDRCWTIANUXFKZOSLHJB; 
                 constexpr static auto turn(std::uint8_t position) -> bool { return position == 25U || position == 12U; } };
  struct VIII  { constexpr static std::array<std::uint8_t, 26> fvalue = FKQHTLXOCBJSPDZRAMEWNIUYGV, 
                                                               rvalue = QJINSAYDVKBFRUHMCPLEWZTGXO; 
                 constexpr static auto turn(std::uint8_t position) -> bool { return position == 25U || position == 12U; } };
  struct BETA  { constexpr static std::array<std::uint8_t, 26> fvalue = LEYJVCNIXWPBQMDRTAKZGFUHOS, 
                                                               rvalue = RLFOBVUXHDSANGYKMPZQWEJICT; 
                 constexpr static auto turn(std::uint8_t position) -> bool { (void)position; return false; } };
  struct GAMMA { constexpr static std::array<std::uint8_t, 26> fvalue = FSOKANUERHMBTIYCWLQPZXVGJD, 
                                                               rvalue = ELPZHAXJNYDRKFCTSIBMGWQVOU; 
                 constexpr static auto turn(std::uint8_t position) -> bool { (void)position; return false; } };
  // clang-format on
} // namespace enmach::rotor_tags

namespace enmach
{
  template<class RotorTag>
  struct Rotor
  {
  public:
    [[nodiscard]] constexpr auto forward(std::uint8_t index) const noexcept -> std::uint8_t
    {
      index = (index + this->effective_offset) % enmach::ETW.size();
      index = RotorTag::fvalue[index];
      index = (index + enmach::ETW.size() - this->effective_offset) % enmach::ETW.size();
      return index;
    }

    [[nodiscard]] constexpr auto inverse(std::uint8_t index) const noexcept -> std::uint8_t
    {
      index = (index + this->effective_offset) % enmach::ETW.size();
      index = RotorTag::rvalue[index];
      index = (index + enmach::ETW.size() - this->effective_offset) % enmach::ETW.size();
      return index;
    }

    [[nodiscard]] constexpr auto increment(const bool should_step, const bool can_propagate) noexcept -> bool
    {
      const bool result = RotorTag::turn((this->effective_offset + this->ringstellung_) % ETW.size());
      if constexpr (!std::is_same_v<RotorTag, enmach::rotor_tags::GAMMA> && !std::is_same_v<RotorTag, enmach::rotor_tags::BETA>)
        this->effective_offset = (this->effective_offset + static_cast<std::uint8_t>(should_step || (result && can_propagate))) % enmach::ETW.size();
      return result;
    }

    template<class T>
    constexpr auto setGrundstellung(T grundstellung) -> void
    {
      if constexpr (std::is_same_v<T, char>)
        this->grundstellung_ = static_cast<std::uint8_t>(to_lowercase_or_die(grundstellung) - 'a');
      else
        this->grundstellung_ = static_cast<std::uint8_t>(grundstellung % ETW.size());
      this->setInternalDifference();
    }

    template<class T>
    constexpr auto setRingstellung(T ringstellung) -> void
    {
      if constexpr (std::is_same_v<T, char>)
        this->ringstellung_ = static_cast<std::uint8_t>(to_lowercase_or_die(ringstellung) - 'a');
      else
        this->ringstellung_ = static_cast<std::uint8_t>(ringstellung % ETW.size());
      this->setInternalDifference();
    }

  private:
    constexpr auto setInternalDifference() noexcept -> void { this->effective_offset = (this->grundstellung_ + enmach::ETW.size() - this->ringstellung_) % enmach::ETW.size(); }

    std::uint8_t grundstellung_{};
    std::uint8_t ringstellung_{};
    std::uint8_t effective_offset{};
  };
} // namespace enmach
#endif // ENMACH_ROTOR_HPP_